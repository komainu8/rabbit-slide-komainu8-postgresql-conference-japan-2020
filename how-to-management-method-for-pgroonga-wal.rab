= PGroonga運用技法

 : subtitle
    ~PGroongaのWALを\n放置していませんか？~
 : author
    堀本泰弘
 : institution
    クリアコード
 : content-source
    PostgreSQL Conference Japan 2020
 : date
    2020-11-13
 : allotted-time
    45m
 : start-time
    2020-11-13T16:10:00+09:00
 : end-time
    2020-09-18T16:55:00+09:00
 : theme
    .

= 自己紹介

  # image
  # src = images/self-introduction.png
  # relative_height = 107

= 今日のテーマ

PGroongaの\nレプリケーションを\n((*うまく*))使おう

= PGroongaの紹介

...の前に

= PGroongaの紹介

そもそも、PGroongaとは？

= PGroongaとは？

PostgreSQL経由で\n((*高速な全文検索*))ができる拡張

= 使い方(インデックス設定)

↓のように使う

  # coderay sql

  CREATE TABLE memos (
    id integer,
    content text
  );

  CREATE INDEX pgroonga_content_index
  ON memos
  USING pgroonga (content);

= 使い方(全文検索)

  # coderay sql

  INSERT INTO memos
  VALUES (1, 'PostgreSQLはリレーショナル・データベース管理システムです。');

  INSERT INTO memos
  VALUES (2, 'Groongaは日本語対応の高速な全文検索エンジンです。');

  SELECT * FROM memos WHERE content &@ '全文検索';
  --  id |                      content                      
  -- ----+---------------------------------------------------
  --   2 | Groongaは日本語対応の高速な全文検索エンジンです。
  -- (1 row)

= 使い方

((*簡単！*))\n
B-treeやGINと同じように使える

= 速度

((*超*))速い

= 速度

追加されたデータは((*即時*))検索可能

= 速度

検索可能になるのが((*速い*))

= 速度

更新中も検索性能が((*落ちない*))

= 速度

ヒット数が多くても検索性能が((*落ちない*))

= 速度

((*安定して*))速い

= 速度

* ベンチマーク
  * ((<URL:https://pgroonga.github.io/ja/reference/pgroonga-versus-pg-bigm.html>))

= 今日のテーマ

PGroongaの\nレプリケーションを\n((*うまく*))使おう

= PGroongaのレプリケーション

* 使うだけなら難しくない
  * PostgreSQLのストリーミングレプリケーションと手順はほぼ同じ
  * 手順もまとまっている
    * ((<URL:https://pgroonga.github.io/ja/reference/streaming-replication.html>))

= レプリケーションのメリット

* PGroongaはインデックスサイズが大きい

= レプリケーションのメリット

* 予備系に切り替わった後にREINDEで復旧すると時間がかかる

= レプリケーションのメリット

* REINDEXは格納されているデータからインデックスを生成

= レプリケーションのメリット

* データ量が多いほど時間がかかる

= レプリケーションのメリット

* レプリケーションしていると、REINDEXせずに復旧できる

= レプリケーションのメリット

復旧時間を\n短縮できる

= PGroongaのレプリケーション

しかし

= PGroongaのレプリケーション

ただ使っている\nだけだと、\n((*困る*))ことがある

= PGroongaのレプリケーション

例えば...

* 現用系がクラッシュしたので、\n予備系に切り替えたらPGroongaのインデックスが破損
  * PGroongaもレプリケーションしていたのに...

= PGroongaのレプリケーション

  # image
  # src = images/broken-index.png
  # relative_width = 90

= PGroongaのレプリケーション

例えば...

* PGroongaのインデックスのファイルサイズが増加し続ける
  * 定期的にVACUUMしているのに...

= PGroongaのレプリケーション

  # image
  # src = images/increase-file-size.png
  # relative_width = 90

= PGroongaのレプリケーション

なぜ

* (1) インデックスが破損するのか？

= インデックス破損の原因

クラッシュセーフ((*じゃない*))から

= インデックス破損の原因

以下の処理中にクラッシュするとREINDEXでの復旧が必要

* PGroongaのインデックス更新中
* 削除済みのレコードに対する検索中
* VACUUM実行中

= レプリケーションの注意点

* PGroongaのインデックス更新中の破損を図で書く

= レプリケーションの注意点

* 削除済みのレコードに対する検索中の破損を図で書く

= レプリケーションの注意点

* VACUUM実行中の破損を図で書く

= レプリケーションの注意点

なので

= レプリケーションの注意点

* 予備系に切り替わったときの状況によってはREINDEXが必要

= PGroongaのレプリケーション

なぜ

* (2) ファイルサイズが増加しつづけるのか？

= ファイルサイズ増加の原因

原因はPGroongaのWAL

= ファイルサイズ増加の原因

PGroongaのWALは削除しないと((*増え続ける*))

= ファイルサイズ増加の原因

つまり

= ファイルサイズ増加の原因

(1) PGroongaのストリーミング機能を使っていて
(2) 何もせずにずっと運用していると

= ファイルサイズ増加の原因

* ファイルサイズがどんどん増加し続けて\nいずれストレージを満杯にする

= PGroongaのWALの運用方法

なので

= PGroongaのWALの運用方法

PGroongaのWALは((*定期的なメンテナンス*))が必要

= PGroongaのWALの運用方法

ファイルサイズの増加を防ぐには？

= PGroongaのWALの運用方法

(1) REINDEXによるインデックス再構築
(2) WALを定期的に削除

= REINDEX

* REINDEXすると、0から再生成
* 古いインデックスは、VACUUM時に削除
  * このときにWALも削除される

= REINDEX

ただ

= REINDEX

REINDEXによるインデックス再構築はデータ量が多いと時間がかかる

= WALの定期的な削除

PGroongaのWALのを削除するには、 pgroonga_wal_trancate を使う

= WALの定期的な削除

↓のようにすればWALを削除できる

  # coderay sql

    SELECT pgroonga_wal_truncate('インデックス名');

= WALの定期的な削除

しかし

= WALの定期的な削除

ただ、単純に削除すると、未適用のWALまで削除してしまう可能性がある

= PGroongaのWALの運用方法

削除前に、確実なWALの適用が必要

= PGroongaのWALの運用方法

明示的なWALの適用は、 pgroonga_wal_apply を使う

= PGroongaのWALの運用方法

  # coderay sql

    SELECT pgroonga_wal_apply('インデックス名');

= PGroongaのWALの運用方法

まとめると

= PGroongaのWALの運用方法

(1) プライマリーのDBで対象のテーブルをロック
(2) すべてのセカンダリーのDB程度でWALを適用
(3) プライマリーのDB程度でWALを削除
(4) テーブルのロックを解除

= PGroongaのWALの運用方法

* プライマリーのDBで対象のテーブルをロックの図

= PGroongaのWALの運用方法

* すべてのセカンダリーのDB程度でWALを適用の図

= PGroongaのWALの運用方法

* プライマリーのDBでWALを削除の図

= PGroongaのWALの運用方法

* テーブルのロックを解除の図

= メンテナンス方法の選択

(1) REINDEXによるインデックス再構築
(2) WALを定期的に削除

のどちらが良いのか？

= メンテナンス方法の選択

* REINDEX
  * 時間がかかる
  * REINDEX中は検索、更新がブロックされる
  * 実行コマンドは少なく実行は手間ではない

= メンテナンス方法の選択

* WALの定期的な削除
  * テーブルをロックしないといけない
  * すべての待機系でWALを適用しないといけない
  * REINDEXと比較して時間はかからない

= メンテナンス方法の選択

* サービスを継続したままインデックスを再構築するという方法もある

= メンテナンス方法の選択

* CREATE INDEX CONCURRENTLY を使う

= メンテナンス方法の選択

ただ

= メンテナンス方法の選択

* この方法は

  (1) インデックスの構築にかなり時間がかかる
  (2) インデックス構築中はパフォーマンスが低下する

= メンテナンス方法の選択

* 長時間パフィーマンスが低下した状態が続くのでおすすめしない。

= メンテナンス方法の選択

* 長時間のサービスの停止時間が許容できるならREINDEX
  * 例えば夜間に実行するなど

= メンテナンス方法の選択

* DBの規模が小さいならREINDEX

= メンテナンス方法の選択

* 長時間のサービス停止が難しいならWALの削除

= まとめ

* PGroongaのレプリケーションでは以下の2点に注意して使う

  * クラッシュセーフではない
  * WALの定期的な削除が必要

= まとめ

PGroongaの\nレプリケーションを\n((*うまく*))使うことができました！！

= 最後に

* PGroongaについての疑問等は、GitHub、Gitterにて
* ドキュメントも充実
  * ((<"https://pgroonga.github.io/ja/"|URL:https://pgroonga.github.io/ja/>))

= 最後に

より突っ込んだお話がしたい場合は↓↓\n
問い合わせ先：

(('tag:x-small'))
((<"https://www.clear-code.com/contact/?type=groonga"|URL:https://www.clear-code.com/contact/?type=groonga>))

= 最後に

ご静聴ありがとうございました
