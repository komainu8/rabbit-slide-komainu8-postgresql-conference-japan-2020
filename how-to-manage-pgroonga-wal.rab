= PGroonga運用技法

 : subtitle
    ~PGroongaのWALを\n放置していませんか？~
 : author
    堀本泰弘
 : institution
    クリアコード
 : content-source
    PostgreSQL Conference Japan 2020
 : date
    2020-11-13
 : allotted-time
    45m
 : start-time
    2020-11-13T16:10:00+09:00
 : end-time
    2020-11-13T16:55:00+09:00
 : theme
    .

= 自己紹介

  # image
  # src = images/self-introduction.png
  # relative_height = 107

= 今日のテーマ

PGroongaの\nWALを\n((*うまく*))使おう

= PGroongaの紹介

の前に...

= PGroongaの紹介

(知らない人向け)\n
PGroonga紹介

= PGroongaの紹介

PGroongaとは？

= PGroongaの紹介

PostgreSQL経由で\n((*高速な全文検索*))

= PGroongaの特徴

(1) ((*簡単*))に使える
(2) ((*速い*))

= PGroongaの使い方

((*簡単*))に使える

= PGroongaの使い方

実際に全文検索\nしてみましょう

= PGroongaの使い方

  # coderay sql

  CREATE TABLE memos (
    id integer,
    content text
  );

  CREATE INDEX pgroonga_content_index
  ON memos
  USING pgroonga (content);

= PGroongaの使い方

  # coderay sql

  INSERT INTO memos
  VALUES (1,
          'PostgreSQLはリレーショナル・データベース管理システムです。');

  INSERT INTO memos
  VALUES (2,
          'Groongaは日本語対応の高速な全文検索エンジンです。');

= PGroongaの使い方

準備完了

= PGroongaの使い方

  # coderay sql

  SELECT *
    FROM memos
    WHERE content &@ '全文検索';

  --  id |                      content                      
  -- ----+---------------------------------------------------
  --   2 | Groongaは日本語対応の高速な全文検索エンジンです。
  -- (1 row)

= PGroongaの使い方

((*簡単*))ですね！

= PGroongaの速度

((*速い*))

= PGroongaの速度

追加されたデータは((*即時*))検索可能

= PGroongaの速度

つまり

= PGroongaの速度

検索可能になるのが((*速い*))

= PGroongaの速度

更新中も検索性能が((*落ちない*))

= PGroongaの速度

ヒット数が多くても検索性能が\n((*落ちない*))

= PGroongaの速度

PGroongaは\n
((*安定して*))速い

= PGroongaの速度

もちろん\n検索も((*速い*))

= PGroongaの速度

* ベンチマーク
  * ((<URL:https://pgroonga.github.io/ja/reference/pgroonga-versus-pg-bigm.html>))

= PGroongaの特徴

さらに

= PGroongaの特徴

((*継続*))してメンテナンスされている

= PGroongaの特徴

PostgreSQL13\nにも対応！

= PGroongaの紹介

以上、PGroongaの紹介でした

= 今日のテーマ

本題に入ります

= 今日のテーマ

PGroongaの\nWALを\n((*うまく*))使おう

= WALとは？

Write Ahead Log\n

= WALとは

  # image
  # src = images/WAL1.png
  # relative_width = 70

= WALの使い方

どのように\n使うのか？

= WALの使い方

クラッシュ\nリカバリー

= WALの使い方

  # image
  # src = images/crush-recovery.png
  # relative_width = 90

= WALの使い方

ストリーミング\nレプリケーション

= WALの使い方

  # image
  # src = images/streaming-replication.png
  # relative_width = 90

= WALの使い方

ポイントイン\nタイムリカバリー

= WALの使い方

ポイントインタイムリカバリーの図

= PGroongaのWAL

PGroongaの\nインデックスもWALが使える

= PGroongaのWAL

WALから\nインデックスの\n復元ができる

= PGroongaのWAL

WALから\n復元できると\n何が良いのか？

= PGroongaのWAL

WALがない\n場合の復元

= PGroongaのWAL

REINDEXを使う

= PGroongaのWAL

PGroongaは\nインデックス\nサイズが大きい

= PGroongaのWAL

インデックス対象のデータが大きいとREINDEXに時間かかる

= PGroongaのWAL

WALから復旧することで、復旧時間を短縮できる

= PGroongaのWAL

* 使うだけなら難しくない
  * pgroonga.enable_wal を true にするだけ

= PGroongaのWAL

* PostgreSQLのWALと同じように復旧に使える
  * クラッシュリカバリー
  * PITR
  * レプリケーション

= WALのメリット

復旧時間を\n短縮できる

= PGroongaのWAL

しかし

= PGroongaのレプリケーション

ただ使っている\nだけだと、\n((*困る*))ことがある

= PGroongaのWALの注意点

例えば
* クラッシュセーフではないので、PGroongaのインデックス更新中にクラッシュした場合はWALから復旧できないことがある。

= PGroongaのWALの注意点

なぜ？

= PGroongaのWALの注意点

インデックス更新中にクラッシュすると、PGroongaの内部で動作しているGroongaのDBにロックが残留していることがあるので、その状態だと、復旧できない。

= PGroongaのWALの注意点

なので

= PGroongaのWALの注意点

このケースだとWALは使えないので、REINDEXでインデックスを再構築する必要がある。

= PGroongaのWALの注意点

例えば

* PGroongaのインデックスのファイルサイズが増加し続ける
  * 定期的にVACUUMしているのに...

= PGroongaのレプリケーション

  # image
  # src = images/increase-file-size.png
  # relative_width = 90

= PGroongaのレプリケーション

なぜ？

= ファイルサイズ増加の原因

原因はPGroongaのWAL

= ファイルサイズ増加の原因

PGroongaのWALは削除しないと\n((*増え続ける*))

= ファイルサイズ増加の原因

つまり

= ファイルサイズ増加の原因

(1) PGroongaのWALを有効にしていて
(2) 何もせずにずっと運用していると

= ファイルサイズ増加の原因

* ファイルサイズがどんどん増加し続けて\nいずれストレージを食いつぶす。。。

= PGroongaのWALの運用方法

なので

= PGroongaのWALの運用方法

PGroongaのWALは((*定期的なメンテナンス*))が必要

= PGroongaのWALの運用方法

ファイルサイズの増加を防ぐには？

= PGroongaのWALの運用方法

(1) REINDEXによるインデックス再構築
(2) WALを定期的に削除

= REINDEX

* REINDEXすると、インデックスを0から再生成
* 古いインデックスは、VACUUM時に削除
  * このときにWALも削除される

= REINDEX

ただ

= REINDEX

REINDEXによるインデックス再構築はデータ量が多いと時間がかかる

= WALの定期的な削除

PGroongaのWALを削除するには、 pgroonga_wal_truncate を使う

= WALの定期的な削除

↓のようにすればWALを削除できる

  # coderay sql

    SELECT pgroonga_wal_truncate('インデックス名');

= WALの定期的な削除

しかし

= WALの定期的な削除

ただ、単純に削除すると、未適用のWALまで削除してしまう可能性がある

= PGroongaのWALの運用方法

削除前に、確実なWALの適用が必要

= PGroongaのWALの運用方法

明示的なWALの適用は、 pgroonga_wal_apply を使う

= PGroongaのWALの運用方法

  # coderay sql

    SELECT pgroonga_wal_apply('インデックス名');

= PGroongaのWALの運用方法

まとめると

= PGroongaのWALの運用方法

(1) プライマリーのDBで対象のテーブルをロック
(2) すべてのセカンダリーのDBでWALを適用
(3) プライマリーのDBでWALを削除
(4) テーブルのロックを解除

= PGroongaのWALの運用方法

* 1ー4の図を書く

= メンテナンス方法の選択

(1) REINDEXによるインデックス再構築
(2) WALを定期的に削除

のどちらが良いのか？

= メンテナンス方法の選択

* REINDEX
  * 時間がかかる
  * REINDEX中は検索、更新がブロックされる
  * 実行コマンドは少なく実行は手間ではない

= メンテナンス方法の選択

* WALの定期的な削除
  * テーブルをロックしないといけない
  * すべての待機系でWALを適用しないといけない
  * REINDEXと比較して時間はかからない

= メンテナンス方法の選択

* サービスを継続したままインデックスを再構築するという方法もある

= メンテナンス方法の選択

* REINDEX CONCURRENTLY を使う
  * PostgreSQL 12 以降

= メンテナンス方法の選択

ただ

= メンテナンス方法の選択

* この方法は

  (1) インデックスの構築にかなり時間がかかる
  (2) インデックス構築中はパフォーマンスが低下する

= メンテナンス方法の選択

* 長時間パフォーマンスが低下した状態が続くのでおすすめしない。

= メンテナンス方法の選択

* 長時間のサービスの停止時間が許容できるならREINDEX
  * 例えば夜間に実行するなど

= メンテナンス方法の選択

* DBの規模が小さいならREINDEX

= メンテナンス方法の選択

* 長時間のサービス停止が難しいならWALの削除

= PostgreSQLのWAL

* PostgreSQLのWALはこのような作業は必要ない。

= PostgreSQLのWAL

* PostgreSQLはmax_wal_sizeとレプリケーションしている場合はwal_keep_segmentsというパラメータでWALの最大サイズを制御している

= PostgreSQLのWAL

* PGroongaには、PostgreSQLと同程度の機能はまだない。

= PostgreSQLのWAL

* 今後の拡張案としてPostgreSQL本体みたいな機能を追加するというのがある
* すぐに欲しい人はサポートを買って依頼

= まとめ

PGroongaの\nWALを\n((*うまく*))使うことができました！！

= 最後に

* PGroongaについての疑問等は、GitHub、Gitterにて
* ドキュメントも充実
  * ((<"https://pgroonga.github.io/ja/"|URL:https://pgroonga.github.io/ja/>))

= 最後に

より突っ込んだお話がしたい場合は↓↓\n
問い合わせ先：

(('tag:x-small'))
((<"https://www.clear-code.com/contact/"|URL:https://www.clear-code.com/contact/>))
